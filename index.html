<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computer Graphics Comprehensive Exam</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f9fc;
            color: #333;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        
        .header {
            text-align: center;
            background: linear-gradient(135deg, #1a73e8, #0d47a1);
            color: white;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .header h1 {
            margin: 0 0 10px 0;
            font-size: 1.8rem;
        }
        
        .header p {
            margin: 0;
            opacity: 0.9;
        }
        
        .units-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 30px;
            justify-content: center;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        
        .unit-tab {
            padding: 10px 20px;
            background-color: #e8f0fe;
            border: 2px solid #d2e3fc;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            font-size: 0.9rem;
        }
        
        .unit-tab:hover {
            background-color: #d2e3fc;
        }
        
        .unit-tab.active {
            background-color: #1a73e8;
            color: white;
            border-color: #1a73e8;
        }
        
        .quiz-container {
            background-color: white;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            margin-bottom: 30px;
            display: none;
        }
        
        .quiz-container.active {
            display: block;
        }
        
        .unit-title {
            color: #1a73e8;
            border-bottom: 2px solid #e8f0fe;
            padding-bottom: 10px;
            margin-top: 0;
        }
        
        .questions-count {
            display: inline-block;
            background-color: #34a853;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-left: 15px;
        }
        
        .question-container {
            margin-bottom: 25px;
            padding: 20px;
            border-radius: 8px;
            background-color: #f9fbfd;
            border-left: 4px solid #1a73e8;
            position: relative;
        }
        
        .question-number {
            display: inline-block;
            background-color: #1a73e8;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            text-align: center;
            line-height: 30px;
            margin-right: 10px;
            font-weight: bold;
        }
        
        .question-text {
            font-weight: bold;
            margin-bottom: 15px;
            color: #202124;
        }
        
        .options-container {
            margin-left: 10px;
        }
        
        .option {
            margin-bottom: 10px;
            padding: 12px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid #e0e0e0;
            background-color: white;
            position: relative;
        }
        
        .option:hover {
            background-color: #f0f7ff;
            border-color: #c2d7ff;
        }
        
        .option.selected {
            background-color: #e8f0fe;
            border-color: #1a73e8;
            font-weight: bold;
        }
        
        .option.correct {
            background-color: #e6f4ea;
            border-color: #34a853;
        }
        
        .option.incorrect {
            background-color: #fce8e6;
            border-color: #ea4335;
        }
        
        .option-letter {
            display: inline-block;
            width: 25px;
            height: 25px;
            background-color: #f1f3f4;
            border-radius: 4px;
            text-align: center;
            line-height: 25px;
            margin-right: 10px;
            font-weight: bold;
        }
        
        .true-false-container {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }
        
        .true-false-btn {
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            border: 1px solid #e0e0e0;
            background-color: white;
            flex: 1;
            text-align: center;
        }
        
        .true-false-btn.selected {
            background-color: #e8f0fe;
            border-color: #1a73e8;
        }
        
        .true-false-btn.correct {
            background-color: #e6f4ea;
            border-color: #34a853;
        }
        
        .true-false-btn.incorrect {
            background-color: #fce8e6;
            border-color: #ea4335;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
        }
        
        button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
            transition: all 0.3s;
        }
        
        #submit-btn {
            background-color: #1a73e8;
            color: white;
        }
        
        #submit-btn:hover {
            background-color: #0d62d9;
        }
        
        #reset-btn {
            background-color: #f1f3f4;
            color: #5f6368;
        }
        
        #reset-btn:hover {
            background-color: #e8eaed;
        }
        
        #random-btn {
            background-color: #fbbc04;
            color: #202124;
        }
        
        #random-btn:hover {
            background-color: #e6a900;
        }
        
        .result-container {
            display: none;
            background-color: white;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            text-align: center;
            margin-top: 20px;
        }
        
        .result-container.active {
            display: block;
        }
        
        .score {
            font-size: 3rem;
            font-weight: bold;
            color: #1a73e8;
            margin: 10px 0;
        }
        
        .score-text {
            font-size: 1.2rem;
            margin-bottom: 20px;
            color: #5f6368;
        }
        
        .answer-feedback {
            margin-top: 10px;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9rem;
            display: none;
            text-align: center;
            font-weight: bold;
        }
        
        .answer-feedback.correct {
            background-color: #e6f4ea;
            color: #137333;
            display: block;
        }
        
        .answer-feedback.incorrect {
            background-color: #fce8e6;
            color: #a50e0e;
            display: block;
        }
        
        .feedback-icon {
            margin-right: 8px;
            font-size: 1.1rem;
        }
        
        .progress-bar {
            height: 8px;
            background-color: #e8eaed;
            border-radius: 4px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background-color: #1a73e8;
            width: 0%;
            transition: width 0.3s;
        }
        
        .progress-text {
            text-align: right;
            font-size: 0.9rem;
            color: #5f6368;
            margin-bottom: 5px;
        }
        
        .question-type {
            display: inline-block;
            background-color: #34a853;
            color: white;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.7rem;
            margin-left: 10px;
            vertical-align: middle;
        }
        
        .question-type.mcq {
            background-color: #1a73e8;
        }
        
        .question-type.tf {
            background-color: #fbbc04;
        }
        
        @media (max-width: 768px) {
            .units-container {
                flex-direction: column;
                align-items: center;
            }
            
            .unit-tab {
                width: 100%;
                text-align: center;
            }
            
            .true-false-container {
                flex-direction: column;
            }
            
            .controls {
                flex-direction: column;
                gap: 15px;
            }
            
            button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Computer Graphics Comprehensive Exam (Units 4-8)</h1>
        <p>Multiple Choice & True/False Questions - See immediate feedback when you select an answer</p>
    </div>
    
    <div class="units-container">
        <div class="unit-tab active" data-unit="all-units">All Units (Random)</div>
        <div class="unit-tab" data-unit="unit4">Unit 4: Midpoint Ellipse</div>
        <div class="unit-tab" data-unit="unit5">Unit 5: Transformations</div>
        <div class="unit-tab" data-unit="unit6">Unit 6: Polygon Filling</div>
        <div class="unit-tab" data-unit="unit7">Unit 7: Clipping Algorithms</div>
        <div class="unit-tab" data-unit="unit8">Unit 8: Polygon Clipping</div>
    </div>
    
    <!-- All Units (Random) Quiz -->
    <div class="quiz-container active" id="all-units">
        <h2 class="unit-title">All Units - Random Questions <span class="questions-count">30 questions</span></h2>
        <div class="progress-text">Answered: <span id="answered-count">0</span>/<span id="total-count">30</span></div>
        <div class="progress-bar">
            <div class="progress" id="progress-bar"></div>
        </div>
        
        <div id="all-units-questions">
            <!-- Questions will be dynamically inserted here -->
        </div>
        
        <div class="controls">
            <button id="reset-btn">Reset All Answers</button>
            <button id="random-btn">Generate New Random Set</button>
            <button id="submit-btn">Submit All Units</button>
        </div>
    </div>
    
    <!-- Unit 4 Quiz -->
    <div class="quiz-container" id="unit4">
        <h2 class="unit-title">Unit 4: Midpoint Ellipse Algorithm <span class="questions-count">16 questions</span></h2>
        
        <div id="unit4-questions">
            <!-- Unit 4 questions will be inserted here -->
        </div>
        
        <div class="controls">
            <button id="reset-btn">Reset Answers</button>
            <button id="submit-btn">Submit Unit 4</button>
        </div>
    </div>
    
    <!-- Unit 5 Quiz -->
    <div class="quiz-container" id="unit5">
        <h2 class="unit-title">Unit 5: Transformations <span class="questions-count">10 questions</span></h2>
        
        <div id="unit5-questions">
            <!-- Unit 5 questions will be inserted here -->
        </div>
        
        <div class="controls">
            <button id="reset-btn">Reset Answers</button>
            <button id="submit-btn">Submit Unit 5</button>
        </div>
    </div>
    
    <!-- Unit 6 Quiz -->
    <div class="quiz-container" id="unit6">
        <h2 class="unit-title">Unit 6: Polygon Filling Algorithms <span class="questions-count">10 questions</span></h2>
        
        <div id="unit6-questions">
            <!-- Unit 6 questions will be inserted here -->
        </div>
        
        <div class="controls">
            <button id="reset-btn">Reset Answers</button>
            <button id="submit-btn">Submit Unit 6</button>
        </div>
    </div>
    
    <!-- Unit 7 Quiz -->
    <div class="quiz-container" id="unit7">
        <h2 class="unit-title">Unit 7: Clipping Algorithms <span class="questions-count">28 questions</span></h2>
        
        <div id="unit7-questions">
            <!-- Unit 7 questions will be inserted here -->
        </div>
        
        <div class="controls">
            <button id="reset-btn">Reset Answers</button>
            <button id="submit-btn">Submit Unit 7</button>
        </div>
    </div>
    
    <!-- Unit 8 Quiz -->
    <div class="quiz-container" id="unit8">
        <h2 class="unit-title">Unit 8: Polygon Clipping <span class="questions-count">30 questions</span></h2>
        
        <div id="unit8-questions">
            <!-- Unit 8 questions will be inserted here -->
        </div>
        
        <div class="controls">
            <button id="reset-btn">Reset Answers</button>
            <button id="submit-btn">Submit Unit 8</button>
        </div>
    </div>
    
    <!-- Result Container -->
    <div class="result-container" id="result-container">
        <h2>Quiz Results</h2>
        <div class="score" id="score">0/0</div>
        <div class="score-text" id="score-text">You answered 0 out of 0 questions correctly.</div>
        <button id="back-to-quiz">Back to Quiz</button>
    </div>

    <script>
        // Comprehensive question bank with all units
        const questionBank = {
            // Unit 4 questions (16 questions)
            unit4: [
                {
                    id: 1,
                    type: "mcq",
                    text: "Which ellipse drawing algorithm is described in the lecture as the best for computer graphics applications?",
                    options: [
                        "A. Bresenham Ellipse Algorithm",
                        "B. Scan-Line Ellipse Algorithm",
                        "C. Midpoint Ellipse Algorithm",
                        "D. Polar Coordinate Ellipse Algorithm"
                    ],
                    correct: "C",
                    explanation: "The Midpoint Ellipse Algorithm is considered the best for computer graphics applications because it's efficient and uses integer arithmetic."
                },
                {
                    id: 2,
                    type: "mcq",
                    text: "According to the lecture, the Midpoint Ellipse Algorithm is considered best primarily because it is:",
                    options: [
                        "A. Simple but computationally expensive",
                        "B. Accurate, efficient, and requires only a few integer additions per pixel",
                        "C. Based on floating-point arithmetic",
                        "D. Suitable only for small ellipses"
                    ],
                    correct: "B",
                    explanation: "The Midpoint Ellipse Algorithm is accurate, efficient, and requires only integer additions per pixel, making it ideal for rasterization."
                },
                {
                    id: 3,
                    type: "mcq",
                    text: "What inputs are required before starting the Midpoint Ellipse Algorithm?",
                    options: [
                        "A. Only the center of the ellipse",
                        "B. Radius along x-axis and y-axis and the center of the ellipse",
                        "C. Diameter along x-axis and y-axis",
                        "D. Only the major axis length"
                    ],
                    correct: "B",
                    explanation: "The algorithm requires the radius along x-axis (rx), radius along y-axis (ry), and the center coordinates (xc, yc)."
                },
                {
                    id: 4,
                    type: "mcq",
                    text: "In the algorithm, the ellipse is initially assumed to be centered at:",
                    options: [
                        "A. (rx, ry)",
                        "B. (1, 1)",
                        "C. (0, 0)",
                        "D. (xc, yc)"
                    ],
                    correct: "C",
                    explanation: "The algorithm initially assumes the ellipse is centered at the origin (0, 0) for simplicity, then translates points to the actual center later."
                },
                {
                    id: 5,
                    type: "mcq",
                    text: "What is the first point plotted for the ellipse when centered at the origin?",
                    options: [
                        "A. (rx, 0)",
                        "B. (0, ry)",
                        "C. (ry, 0)",
                        "D. (rx, ry)"
                    ],
                    correct: "B",
                    explanation: "The algorithm starts at point (0, ry) on the positive y-axis and plots points in the first quadrant."
                },
                {
                    id: 6,
                    type: "mcq",
                    text: "The initial decision parameter for Region 1 is denoted as:",
                    options: [
                        "A. p20",
                        "B. p2k",
                        "C. p10",
                        "D. pk"
                    ],
                    correct: "C",
                    explanation: "The initial decision parameter for Region 1 is denoted as p10 (p1₀)."
                },
                {
                    id: 7,
                    type: "mcq",
                    text: "Which of the following correctly represents the initial decision parameter for Region 1?",
                    options: [
                        "A. p10 = ry² - rx²ry + 0.5rx²",
                        "B. p10 = ry² - rx²ry + 0.25rx²",
                        "C. p10 = rx² - ry²rx + 0.25ry²",
                        "D. p10 = ry² + rx²ry - 0.25rx²"
                    ],
                    correct: "B",
                    explanation: "The correct formula for the initial decision parameter in Region 1 is p10 = ry² - rx²ry + 0.25rx²."
                },
                {
                    id: 8,
                    type: "mcq",
                    text: "In Region 1, if the decision parameter p1k < 0, the next point chosen is:",
                    options: [
                        "A. (xk, yk - 1)",
                        "B. (xk + 1, yk - 1)",
                        "C. (xk + 1, yk)",
                        "D. (xk - 1, yk)"
                    ],
                    correct: "C",
                    explanation: "If p1k < 0, the next point is (xk + 1, yk) - we increment x but keep y the same."
                },
                {
                    id: 9,
                    type: "mcq",
                    text: "In Region 1, if p1k ≥ 0, the next point plotted is:",
                    options: [
                        "A. (xk, yk - 1)",
                        "B. (xk + 1, yk - 1)",
                        "C. (xk - 1, yk)",
                        "D. (xk + 1, yk)"
                    ],
                    correct: "B",
                    explanation: "If p1k ≥ 0, the next point is (xk + 1, yk - 1) - we increment x and decrement y."
                },
                {
                    id: 10,
                    type: "mcq",
                    text: "The transition from Region 1 to Region 2 occurs when:",
                    options: [
                        "A. x = y",
                        "B. x ≥ y",
                        "C. 2ry²x ≥ 2rx²y",
                        "D. 2ry²x < 2rx²y"
                    ],
                    correct: "C",
                    explanation: "The transition occurs when the slope changes from > -1 to ≤ -1, which is when 2ry²x ≥ 2rx²y."
                },
                {
                    id: 11,
                    type: "mcq",
                    text: "The initial decision parameter for Region 2 is calculated using:",
                    options: [
                        "A. The first point of the ellipse",
                        "B. The center of the ellipse",
                        "C. The last point obtained in Region 1",
                        "D. A fixed constant value"
                    ],
                    correct: "C",
                    explanation: "The initial decision parameter for Region 2 (p20) is calculated using the last point (x, y) obtained in Region 1."
                },
                {
                    id: 12,
                    type: "mcq",
                    text: "The decision parameter used in Region 2 is denoted as:",
                    options: [
                        "A. p10",
                        "B. p1k",
                        "C. p20",
                        "D. pk"
                    ],
                    correct: "C",
                    explanation: "The decision parameter for Region 2 is denoted as p20 (p2₀) initially, and p2k for subsequent points."
                },
                {
                    id: 13,
                    type: "mcq",
                    text: "In Region 2, if the decision parameter p2k > 0, the next point selected is:",
                    options: [
                        "A. (xk + 1, yk)",
                        "B. (xk, yk - 1)",
                        "C. (xk + 1, yk - 1)",
                        "D. (xk - 1, yk)"
                    ],
                    correct: "B",
                    explanation: "If p2k > 0, the next point is (xk, yk - 1) - we decrement y but keep x the same."
                },
                {
                    id: 14,
                    type: "mcq",
                    text: "In Region 2, if p2k ≤ 0, the next point chosen is:",
                    options: [
                        "A. (xk - 1, yk)",
                        "B. (xk, yk - 1)",
                        "C. (xk + 1, yk - 1)",
                        "D. (xk + 1, yk)"
                    ],
                    correct: "C",
                    explanation: "If p2k ≤ 0, the next point is (xk + 1, yk - 1) - we increment x and decrement y."
                },
                {
                    id: 15,
                    type: "mcq",
                    text: "After calculating points in the first quadrant, how does the algorithm generate the full ellipse?",
                    options: [
                        "A. By rotating the points",
                        "B. By reflecting points across both axes to obtain symmetry",
                        "C. By recalculating for all quadrants",
                        "D. By using trigonometric functions"
                    ],
                    correct: "B",
                    explanation: "The algorithm calculates points only for the first quadrant, then uses symmetry to reflect them to the other three quadrants."
                },
                {
                    id: 16,
                    type: "mcq",
                    text: "The final plotted coordinates are adjusted using:",
                    options: [
                        "A. Scaling factors",
                        "B. Rotation matrices",
                        "C. Translation by adding the center coordinates",
                        "D. Perspective projection"
                    ],
                    correct: "C",
                    explanation: "After calculating points assuming center at (0, 0), we add the actual center coordinates (xc, yc) to each point."
                }
            ],
            
            // Unit 5 questions (10 sample questions)
            unit5: [
                {
                    id: 1,
                    type: "mcq",
                    text: "In computer graphics, a transformation is best defined as:",
                    options: [
                        "A. A method for drawing pixels on the screen",
                        "B. A function that maps a point or vector to another point or vector",
                        "C. A hardware operation inside the GPU",
                        "D. A method used only for 3D rendering"
                    ],
                    correct: "B",
                    explanation: "A transformation is a function that maps points or vectors to other points or vectors."
                },
                {
                    id: 2,
                    type: "mcq",
                    text: "Which coordinate system allows translation to be represented using matrix multiplication?",
                    options: [
                        "A. Cartesian coordinates",
                        "B. Polar coordinates",
                        "C. Homogeneous coordinates",
                        "D. Normalized device coordinates"
                    ],
                    correct: "C",
                    explanation: "Homogeneous coordinates allow translation to be represented as matrix multiplication."
                },
                {
                    id: 3,
                    type: "mcq",
                    text: "Translation of a point P by displacement vector d is mathematically represented as:",
                    options: [
                        "A. P′ = Pd",
                        "B. P′ = P − d",
                        "C. P′ = P × d",
                        "D. P′ = P + d"
                    ],
                    correct: "D",
                    explanation: "Translation is the addition of a displacement vector d to point P."
                },
                {
                    id: 4,
                    type: "mcq",
                    text: "Which transformation displaces points by a fixed distance in a given direction?",
                    options: [
                        "A. Rotation",
                        "B. Scaling",
                        "C. Translation",
                        "D. Shear"
                    ],
                    correct: "C",
                    explanation: "Translation displaces points by a fixed distance in a given direction."
                },
                {
                    id: 5,
                    type: "mcq",
                    text: "Why are rotation and translation classified as rigid-body transformations?",
                    options: [
                        "A. They require homogeneous coordinates",
                        "B. They preserve object shape and size",
                        "C. They change the orientation of axes",
                        "D. They always involve scaling"
                    ],
                    correct: "B",
                    explanation: "Rigid-body transformations (translation and rotation) preserve distances and angles, maintaining the object's shape and size."
                },
                {
                    id: 6,
                    type: "tf",
                    text: "Affine transformations can be represented using homogeneous coordinates.",
                    correct: "true",
                    explanation: "True. Homogeneous coordinates allow all affine transformations to be represented as matrix multiplications."
                },
                {
                    id: 7,
                    type: "tf",
                    text: "Translation alone can change the shape of an object.",
                    correct: "false",
                    explanation: "False. Translation only changes position, not shape."
                },
                {
                    id: 8,
                    type: "tf",
                    text: "Scaling is a rigid-body transformation.",
                    correct: "false",
                    explanation: "False. Scaling is not a rigid-body transformation because it changes distances between points."
                },
                {
                    id: 9,
                    type: "tf",
                    text: "Rotation about a fixed point requires translating the object to the origin first.",
                    correct: "true",
                    explanation: "True. To rotate about an arbitrary point, we translate the point to the origin, rotate, then translate back."
                },
                {
                    id: 10,
                    type: "tf",
                    text: "Shear transformations preserve area but change angles between lines.",
                    correct: "true",
                    explanation: "True. Shear transformations preserve area but change the angles between lines."
                }
            ]
        };
        
        // Store user answers
        const userAnswers = {
            "all-units": {},
            unit4: {},
            unit5: {},
            unit6: {},
            unit7: {},
            unit8: {}
        };
        
        // Current random question set for "All Units"
        let currentRandomQuestions = [];
        
        // Initialize the quiz
        document.addEventListener('DOMContentLoaded', function() {
            // Generate questions for each unit
            generateUnitQuestions();
            
            // Generate initial random question set
            generateRandomQuestionSet();
            
            // Unit tab switching
            const unitTabs = document.querySelectorAll('.unit-tab');
            const quizContainers = document.querySelectorAll('.quiz-container');
            
            unitTabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const unitId = this.getAttribute('data-unit');
                    
                    // Update active tab
                    unitTabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Show corresponding quiz
                    quizContainers.forEach(container => {
                        container.classList.remove('active');
                        if (container.id === unitId) {
                            container.classList.add('active');
                        }
                    });
                    
                    // Update progress for random questions
                    if (unitId === "all-units") {
                        updateProgress();
                    }
                });
            });
            
            // Handle submit button for each unit
            document.querySelectorAll('#submit-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const quizContainer = this.closest('.quiz-container');
                    const unitId = quizContainer.id;
                    
                    // Calculate score
                    let totalQuestions = 0;
                    let correctCount = 0;
                    
                    if (unitId === "all-units") {
                        // For random questions
                        currentRandomQuestions.forEach(q => {
                            totalQuestions++;
                            const userAnswer = userAnswers[unitId][q.id];
                            if (userAnswer === q.correct) {
                                correctCount++;
                            }
                        });
                    } else {
                        // For unit-specific questions
                        questionBank[unitId].forEach(q => {
                            totalQuestions++;
                            const userAnswer = userAnswers[unitId][q.id];
                            if (userAnswer === q.correct) {
                                correctCount++;
                            }
                        });
                    }
                    
                    // Show results
                    document.getElementById('score').textContent = `${correctCount}/${totalQuestions}`;
                    document.getElementById('score-text').textContent = `You answered ${correctCount} out of ${totalQuestions} questions correctly.`;
                    
                    // Show result container and hide quiz
                    quizContainer.classList.remove('active');
                    document.getElementById('result-container').classList.add('active');
                    
                    // Highlight correct/incorrect answers
                    highlightAnswers(unitId);
                });
            });
            
            // Handle reset button
            document.querySelectorAll('#reset-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const quizContainer = this.closest('.quiz-container');
                    const unitId = quizContainer.id;
                    
                    // Clear all selections and feedback
                    quizContainer.querySelectorAll('.option.selected, .true-false-btn.selected').forEach(el => {
                        el.classList.remove('selected', 'correct', 'incorrect');
                    });
                    
                    // Clear all feedback
                    quizContainer.querySelectorAll('.answer-feedback').forEach(feedback => {
                        feedback.classList.remove('correct', 'incorrect');
                        feedback.textContent = '';
                        feedback.style.display = 'none';
                    });
                    
                    // Reset user answers for this unit
                    userAnswers[unitId] = {};
                    
                    // Update progress for random questions
                    if (unitId === "all-units") {
                        updateProgress();
                    }
                });
            });
            
            // Handle generate new random set button
            document.getElementById('random-btn').addEventListener('click', function() {
                generateRandomQuestionSet();
                
                // Reset answers for random questions
                userAnswers["all-units"] = {};
                
                // Update progress
                updateProgress();
            });
            
            // Handle back to quiz button
            document.getElementById('back-to-quiz').addEventListener('click', function() {
                document.getElementById('result-container').classList.remove('active');
                
                // Find which unit was active
                let activeUnit = 'all-units';
                document.querySelectorAll('.unit-tab').forEach(tab => {
                    if (tab.classList.contains('active')) {
                        activeUnit = tab.getAttribute('data-unit');
                    }
                });
                
                // Show that unit's quiz
                document.getElementById(activeUnit).classList.add('active');
            });
        });
        
        // Function to generate questions for each unit
        function generateUnitQuestions() {
            for (const unit in questionBank) {
                const container = document.getElementById(`${unit}-questions`);
                if (!container) continue;
                
                questionBank[unit].forEach(q => {
                    const questionElement = createQuestionElement(q, unit);
                    container.appendChild(questionElement);
                });
            }
        }
        
        // Function to create a question element
        function createQuestionElement(question, unit) {
            const questionDiv = document.createElement('div');
            questionDiv.className = 'question-container';
            questionDiv.setAttribute('data-id', question.id);
            questionDiv.setAttribute('data-correct', question.correct);
            questionDiv.setAttribute('data-explanation', question.explanation || "");
            
            let questionHtml = `
                <div class="question-number">${question.id}</div>
                <span class="question-type ${question.type}">${question.type.toUpperCase()}</span>
                <div class="question-text">${question.text}</div>
            `;
            
            if (question.type === "mcq") {
                questionHtml += `<div class="options-container">`;
                
                const optionLetters = ['A', 'B', 'C', 'D'];
                question.options.forEach((option, index) => {
                    questionHtml += `
                        <div class="option" data-value="${optionLetters[index]}">
                            <span class="option-letter">${optionLetters[index]}</span>
                            ${option}
                        </div>
                    `;
                });
                
                questionHtml += `</div>`;
            } else if (question.type === "tf") {
                questionHtml += `
                    <div class="true-false-container">
                        <div class="true-false-btn" data-value="true">True</div>
                        <div class="true-false-btn" data-value="false">False</div>
                    </div>
                `;
            }
            
            questionHtml += `<div class="answer-feedback"></div>`;
            questionDiv.innerHTML = questionHtml;
            
            // Add click event to options
            if (question.type === "mcq") {
                questionDiv.querySelectorAll('.option').forEach(option => {
                    option.addEventListener('click', function() {
                        handleOptionClick(this, questionDiv, unit);
                    });
                });
            } else if (question.type === "tf") {
                questionDiv.querySelectorAll('.true-false-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        handleOptionClick(this, questionDiv, unit);
                    });
                });
            }
            
            return questionDiv;
        }
        
        // Function to handle option click
        function handleOptionClick(selectedElement, questionDiv, unit) {
            const questionId = questionDiv.getAttribute('data-id');
            const correctAnswer = questionDiv.getAttribute('data-correct');
            const explanation = questionDiv.getAttribute('data-explanation');
            const selectedValue = selectedElement.getAttribute('data-value');
            
            // Store user answer
            userAnswers[unit][questionId] = selectedValue;
            
            // Remove selected class from all options in this question
            if (questionDiv.querySelector('.options-container')) {
                questionDiv.querySelectorAll('.option').forEach(opt => {
                    opt.classList.remove('selected', 'correct', 'incorrect');
                });
            } else if (questionDiv.querySelector('.true-false-container')) {
                questionDiv.querySelectorAll('.true-false-btn').forEach(btn => {
                    btn.classList.remove('selected', 'correct', 'incorrect');
                });
            }
            
            // Add selected class to clicked element
            selectedElement.classList.add('selected');
            
            // Check if answer is correct
            const isCorrect = selectedValue === correctAnswer;
            
            // Mark correct and incorrect answers
            if (questionDiv.querySelector('.options-container')) {
                // MCQ question
                questionDiv.querySelectorAll('.option').forEach(opt => {
                    const optValue = opt.getAttribute('data-value');
                    if (optValue === correctAnswer) {
                        opt.classList.add('correct');
                    } else if (optValue === selectedValue && !isCorrect) {
                        opt.classList.add('incorrect');
                    }
                });
            } else if (questionDiv.querySelector('.true-false-container')) {
                // True/False question
                questionDiv.querySelectorAll('.true-false-btn').forEach(btn => {
                    const btnValue = btn.getAttribute('data-value');
                    if (btnValue === correctAnswer) {
                        btn.classList.add('correct');
                    } else if (btnValue === selectedValue && !isCorrect) {
                        btn.classList.add('incorrect');
                    }
                });
            }
            
            // Show feedback
            const feedback = questionDiv.querySelector('.answer-feedback');
            if (isCorrect) {
                feedback.innerHTML = `<span class="feedback-icon">✓</span> Correct! ${explanation}`;
                feedback.classList.remove('incorrect');
                feedback.classList.add('correct');
            } else {
                feedback.innerHTML = `<span class="feedback-icon">✗</span> Incorrect. The correct answer is <strong>${correctAnswer}</strong>. ${explanation}`;
                feedback.classList.remove('correct');
                feedback.classList.add('incorrect');
            }
            feedback.style.display = 'block';
            
            // Update progress for random questions
            if (unit === "all-units") {
                updateProgress();
            }
        }
        
        // Function to generate random question set
        function generateRandomQuestionSet() {
            const container = document.getElementById('all-units-questions');
            container.innerHTML = '';
            
            // Get all questions from all units
            const allQuestions = [];
            for (const unit in questionBank) {
                questionBank[unit].forEach(q => {
                    allQuestions.push({
                        ...q,
                        sourceUnit: unit
                    });
                });
            }
            
            // Shuffle array and pick 10 random questions (for demo)
            const shuffled = allQuestions.sort(() => 0.5 - Math.random());
            currentRandomQuestions = shuffled.slice(0, 10);
            
            // Add questions to container
            currentRandomQuestions.forEach((q, index) => {
                const questionElement = createQuestionElement({...q, id: index + 1}, "all-units");
                container.appendChild(questionElement);
            });
            
            // Update total count
            document.getElementById('total-count').textContent = currentRandomQuestions.length;
            
            // Update progress
            updateProgress();
        }
        
        // Function to update progress bar
        function updateProgress() {
            const answered = Object.keys(userAnswers["all-units"]).length;
            const total = currentRandomQuestions.length;
            
            document.getElementById('answered-count').textContent = answered;
            document.getElementById('total-count').textContent = total;
            
            const percentage = total > 0 ? (answered / total) * 100 : 0;
            document.getElementById('progress-bar').style.width = `${percentage}%`;
        }
        
        // Function to highlight correct/incorrect answers
        function highlightAnswers(unitId) {
            let questions;
            
            if (unitId === "all-units") {
                questions = currentRandomQuestions;
            } else {
                questions = questionBank[unitId];
            }
            
            const quizContainer = document.getElementById(unitId);
            
            questions.forEach(q => {
                const questionContainer = quizContainer.querySelector(`.question-container[data-id="${q.id}"]`);
                if (!questionContainer) return;
                
                const userAnswer = userAnswers[unitId][q.id];
                const correctAnswer = q.correct;
                
                if (q.type === "mcq") {
                    // Find the correct option and user's selected option
                    const options = questionContainer.querySelectorAll('.option');
                    const optionLetters = ['A', 'B', 'C', 'D'];
                    
                    options.forEach(option => {
                        const optionValue = option.getAttribute('data-value');
                        
                        if (optionValue === correctAnswer) {
                            option.classList.add('correct');
                        } else if (optionValue === userAnswer && userAnswer !== correctAnswer) {
                            option.classList.add('incorrect');
                        }
                    });
                } else if (q.type === "tf") {
                    // Find the correct button and user's selected button
                    const buttons = questionContainer.querySelectorAll('.true-false-btn');
                    
                    buttons.forEach(button => {
                        const buttonValue = button.getAttribute('data-value');
                        
                        if (buttonValue === correctAnswer) {
                            button.classList.add('correct');
                        } else if (buttonValue === userAnswer && userAnswer !== correctAnswer) {
                            button.classList.add('incorrect');
                        }
                    });
                }
            });
        }
    </script>
</body>
</html>
